---
title: Matchers
description: Match arbitrary chunks of text with regex patterns
order: 2
---

import SchemaAndInput from "../../../components/SchemaAndInput.astro";
import TODO from "../../../components/TODO.astro";

Matchers allow you to validate dynamic content using regular expressions. A matcher is defined using inline code syntax with a specific format: `` `label:/pattern/` ``.

# Syntax

The basic matcher format is:

```
`label:/regex-pattern/`
```

- **label**: An identifier for the matched value (used in validation output)
- **pattern**: A JavaScript-compatible regular expression

The pattern is automatically anchored to the start (as if prefixed with `^`), so it matches from the beginning of the available text.

<SchemaAndInput
  schema={"`name:/\w+/`"}
  input={"Alice"}
  valid={true}
  output={'{"name": "Alice"}'}
/>

<SchemaAndInput
  schema={"`age:/\d+/`"}
  input={"42"}
  valid={true}
  output={'{"age": "42"}'}
/>

<SchemaAndInput schema={"`name:/\w+/`"} input={"123"} valid={false} />

<SchemaAndInput schema={"`age:/\d+/`"} input={"not a number"} valid={false} />

## With Surrounding Text

Matchers can be combined with literal text as prefixes and suffixes:

<SchemaAndInput
  schema={`Name: \`name:/\w+/\``}
  input={"Name: Alice"}
  valid={true}
  output={'{"name":"Alice"}'}
/>

<SchemaAndInput
  schema={`\`count:/\d+/\` items`}
  input={"42 items"}
  valid={true}
  output={'{"count":"42"}'}
/>

<SchemaAndInput
  schema={`User \`id:/\d+/\` logged in`}
  input={"User 123 logged in"}
  valid={true}
  output={'{"id":"123"}'}
/>

<SchemaAndInput
  schema={`Name: \`name:/\w+/\``}
  input={"Name: "}
  valid={false}
/>

<SchemaAndInput
  schema={`\`count:/\d+/\` items`}
  input={"42 things"}
  valid={false}
/>

This also works for spanning nodes of other types, like italics and subsequent code spans via literal matchers (more on this later).

<SchemaAndInput
  schema={`User \`id:/\d+/\` logged in *this is italic*)`}
  input={"User 123 logged in"}
  valid={true}
  output={'{"id":"123"}'}
/>

<SchemaAndInput
  schema={`*test*test\`foo:/bar/\`wolf`}
  input={"*test*testbarwolf"}
  valid={true}
  output={'{"foo":"bar"}'}
/>

## Empty Labels

<TODO />

To match without capturing a value, use an underscore (`_`) as the label:

<SchemaAndInput
  schema={"`_:/\\w+/`"}
  input={"hello"}
  valid={true}
  output={"{}"}
/>

## Multiple matchers

Right now, you can only have one matcher per paragraph (collection of spanning elements). So, for example, the following will not work.

<SchemaAndInput
  schema={"`_:/\w+/` `_:/\w+/`"}
  input={"hello"}
  valid={false}
/>

# Repeating Paragraphs

<TODO />

You can validate multiple paragraph nodes into an array by using a repeated matcher. The repeated matcher syntax will show up again for lists, it looks like `` {min,max} ``, where `min` and `max` are optional.

<SchemaAndInput
  schema={"`\`test:/test/\`{3,3}`"}
  input={"test\ntest\ntest"}
  valid={true}
  output={'{"test":["test","test","test"]}'}
/>

<SchemaAndInput
  schema={"`\`test:/test/\`{,3}`"}
  input={"test\ntest\ntest\ntest"}
  valid={false}
  output={'{"test":["test","test","test"]}'}
/>

The matched content is passed to the executable:
- As arguments (`$0`, `$1`, etc.)
- Via stdin (if command reads from stdin)

# Literal Code Blocks

To match inline code blocks literally instead of treating them as matchers, add `!` after the code block:

<SchemaAndInput
  schema={"\`test\`!"}
  input={"\`test\`"}
  valid={true}
/>

<SchemaAndInput
  schema={"The code is \`example\`! here"}
  input={"The code is \`example\` here"}
  valid={true}
/>

<SchemaAndInput
  schema={"\`test\`!"}
  input={"test"}
  valid={false}
/>

# Everything Matchers

If a matcher has no regex pattern (just a label in backticks), it will match everything available in the current context as an identity function. The syntax is simply `` `label` ``, where the label follows the naming rules below.

## Naming Rules

Matcher labels (both for regex matchers and everything matchers) must follow these rules:

- Must contain only alphanumeric characters (a-z, A-Z, 0-9), hyphens (`-`), and underscores (`_`)
- Cannot contain spaces or other special characters
- Valid examples: `user_name`, `item-count`, `id123`, `MyData`
- Invalid examples: `user name` (space), `data@field` (special char), `item.count` (period)

## Behavior

Everything matchers act as an identity function - they **always** match and return exactly what was passed to them, including special characters, spaces, and any other content:

<SchemaAndInput
  schema={"`foo`"}
  input={"anything goes here"}
  valid={true}
  output={'{"foo":"anything goes here"}'}
/>

<SchemaAndInput
  schema={"`text`"}
  input={"hello world 123!"}
  valid={true}
  output={'{"text":"hello world 123!"}'}
/>

<SchemaAndInput
  schema={"`data`"}
  input={"@*&^R special chars"}
  valid={true}
  output={'{"data":"@*&^R special chars"}'}
/>

When used in a paragraph context, everything matchers will capture all spanning elements including formatting like italics:

<SchemaAndInput
  schema={"`content`"}
  input={"*italic text* and regular text"}
  valid={true}
  output={'{"content":"*italic text* and regular text"}'}
/>

<SchemaAndInput
  schema={"Prefix: `data`"}
  input={"Prefix: *some italic* and more"}
  valid={true}
  output={'{"data":"*some italic* and more"}'}
/>

Everything matchers never fail to match - they accept any input and return it unchanged under the specified label.

### Escaping the Exclamation Mark

<TODO />

Use `!!` to match a literal exclamation mark after code:

<SchemaAndInput
  schema={"\`code\`!!"}
  input={"\`code\`!"}
  valid={true}
/>

# Execution Validation

<TODO />

You can validate content by running an executable. Use the syntax `label:!command`:

<SchemaAndInput
  schema={"`number:!test \\$0 -gt 0`"}
  input={"42"}
  valid={true}
  output={'{"number":"42"}'}
/>

The matched content is passed to the executable:
- As arguments (`$0`, `$1`, etc.)
- Via stdin (if command reads from stdin)

Exit code 0 means validation passes. Any other exit code indicates failure.
