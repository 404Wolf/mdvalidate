---
title: "Software Requirements Specification for *MDvalidate*"
author:
  - Wolf Mermelstein
  - Alesandro Mason
date: "September 22, 2025"
affiliation: "Case Western Reserve University"
toc: true
toc-depth: 3
number-sections: true
format:
  pdf:
    documentclass: article
    geometry: margin=1in
  html:
    theme: default
---

# Introduction

## Purpose {#purpose}

<!-- Alesandro -->

<!-- Describe the purpose of this SRS and its intended audience. -->

This SRS lays out the scope of a Markdown validation and templating tool,
`MDvalidate`. The goal of this document is to motivate the need for such a
tool, explain what exists and why there is currently no equivalent, and outline
the general shape that the project will take.

## Document Conventions {#document-conventions}

<!-- Wolf -->

<!-- Describe any standards or typographical conventions that were followed when
writing this SRS, such as fonts or highlighting that have special
significance. For example, state whether priorities for higher-level
requirements are assumed to be inherited by detailed requirements, or whether
every requirement statement is to have its own priority. -->

This document is written in [Quarto](https://quarto.org/), a scientific and
technical publishing system.

We assume knowledge of some surrounding technologies like abstract syntax
trees, but defines more specific terms in the glossary section at the end.

## Intended Audience and Reading Suggestions {#intended-audience}

<!-- Wolf -->

<!-- Describe the different types of reader that the document is intended for,
such as developers, project managers, marketing staff, users, testers, and
documentation writers. Describe what the rest of this SRS contains and how it
is organized. Suggest a sequence for reading the document, beginning with the
overview sections and proceeding through the sections that are most pertinent
to each reader type. -->

This document serves as a technical outline for technical of the project for
consumers of semi-structured Markdown data, or developers who interact with
disparate document formats looking for a nice unified standard.

## Project Scope {#project-scope}

<!-- Provide a short description of the software being specified and its purpose,
including relevant benefits, objectives, and goals. Relate the software to
corporate goals or business strategies. If a separate vision and scope
document is available, refer to it rather than duplicating its contents here.
An SRS that specifies the next release of an evolving product should contain
its own scope statement as a subset of the long-term strategic product
vision. -->

`mdvalidate` is a CLI tool and associated library that takes a Markdown file and
performs validation, providing useful information about whether it conforms to
a shape in a schema.

[Markdown](https://learnxinyminutes.com/markdown/) is an unstructured superset
of html that is easy to read and write for humans. It is widely used for
technical documentation, note-taking, and more. However, because it is
unstructured, it can be difficult to ensure that Markdown documents conform to a
specific structure or schema and generally isn't specifically meant to be used
as structured data. MDValidate makes that possible.

The general idea is that you can intake a valid Markdown file like

```{markdown}
# Wolf Mermelstein

This is me!

## Phones
| Type   | Number             |
| :----- | :----------------- |
| Backup | `c!(212) 767-9653` |
| Misc   | `c!(123) 456-789W` |
```

Which is a "unsafe" (a markdown file that does not have a specific shape) file,
and validate it against a schema defined in a custom schema language (that we
will design) that may look something along the lines of

```{txt}
# (name:/([A-Z][a-z]+){2}/) // First Last

(notes:/.+/)
// Notes about the person can go here

## Phones
| Type   | Number             |
| :----- | :----------------- |
(phone_row:| (phone_type:([\w ]+) | `c!(\d{3}) \d{3}-\d{3}` |)
```

To get an error report that might say

```{txt}
Failed to validate!

On line 7, column 40, expected phone_type<regex> to match `c!(\d{3})
\d{3}-\d{4}` but got `c!(123) 456-789W`
```

The beauty of defining a schema in such a way that every Markdown AST node has
a clear definition and label is we will also be able to go from a structured
data format like JSON or YAML to a Markdown document that conforms to the
schema. For example, given the schema above and the JSON data

```json
{
  "name": "Wolf Mermelstein",
  "phone_rows": [
    {"Backup": "(212) 767-9653"},
    {"Misc": "(123) 456-7890"}
  ]
}
```

Back to the original Markdown document.

There's a lot of associated tooling that can be created and built into or for
MDValidate, so we will focus initally on the core validation engine. This will
include:

- A schema definition language for describing the shape of Markdown documents.
- A command line interface for validating Markdown files against schemas.
- A library interface for integrating validation into other applications.

And then, time permitting, we will build out some of the associated tooling:

- A templating engine for generating Markdown documents from schemas and data.
- A language server protocol (LSP) extension for real-time validation in editors.
- Integration into external Markdown tooling, associated Github actions, etc.

MDValidate has the potential to address various real business needs:

- Integration into CI/CD pipelines for Markdown documentation validation.
- Use in other tools that allow users to edit arbitrary document formats as
  Markdown (for example, if you define a tool that can transform any file format
  to JSON, then you define a Markdown schema that can carry all the fields of
  the JSON, then you can make it possible to "edit" those types of files in
  Markdown in a way where it can easily be converted back).

<!-- ## References {#references} -->

<!-- Wolf -->

<!-- List any other documents or Web addresses to which this SRS refers. These may
include user interface style guides, contracts, standards, system
requirements specifications, use case documents, or a vision and scope
document. Provide enough information so that the reader could access a copy
of each reference, including title, author, version number, date, and source
or location. -->
 
## Product Perspective {#product-perspective}

<!-- Wolf -->

<!-- Describe the context and origin of the product being specified in this SRS.
For example, state whether this product is a follow-on member of a product
family, a replacement for certain existing systems, or a new, self-contained
product. If the SRS defines a component of a larger system, relate the
requirements of the larger system to the functionality of this software and
identify interfaces between the two. A simple diagram that shows the major
components of the overall system, subsystem interconnections, and external
interfaces can be helpful. -->

**MDValidate**

The primary "product" will be the command line tool `mdvalidate`, which will
take a schema and a Markdown file (or stream) and output whether the document
conforms to the schema and useful error information, including the line of
issues and why validation failed.

An important subcomponent of the project will be the custom schema definition
language that we will design in the process.

**Meta**

There are currently many tools for working with Markdown.

Some notable ones include linters, like
[markdownlint](https://github.com/DavidAnson/markdownlint), that can validate
Markdown. It will tell you if (and where) you are missing closing tags, for
example, or have bad spacing alignment. There are also formatting tools for
markdown like [Prettier](https://prettier.io/) that can format markdown to a
unified style.

Recently, with the advent of AI, many new Markdown related tools have sprung
into existence, since Markdown is a particularly easy to parse and generate
textual format that can convey a large amount of information in a relatively
small amount of tokens. For example, recently Microsoft has been working on
[MarkItDown](https://github.com/microsoft/markitdown), a tool that can convert
many different inputs, like PDFs, word documents, and more to Markdown. There
are also traditional document conversion tools, like
[Pandoc](https://pandoc.org/), that can convert between many different document
formats, including Markdown, that have gained popularity.

**Gaps**

Right now, there are many great options to work with Markdown, edit markdown,
generate Markdown, and display or render Markdown, but there is no great way to
actually validate or template Markdown. There's even tools dedicated to Markdown
AST manipulation for end users, to make it easy to make websites that can
display Markdown, via the [remark/rehype](https://github.com/remarkjs/remark)
ecosystem.

You can use common templating tools like [handlebars](https://handlebarsjs.com/)
to take structured data and place it into valid Markdown, but there's no great
way to then go back in the other direction.

## Product Features {#product-features}

<!-- Alesandro -->

<!-- Summarize the major features the product contains or the significant
functions that it performs or lets the user perform. Details will be provided
in Section 3, so only a high level summary is needed here. Organize the
functions to make them understandable to any reader of the SRS. A picture of
the major groups of related requirements and how they relate, such as a top
level data flow diagram or a class diagram, is often effective. -->

Core features include:

- Defining a schema for a Markdown document.
- Validating a Markdown document against a schema.
- Generating a Markdown document from a schema and data.

Further key features include:

- Editor integration via Language Server Protocol. This lets users of
  MDvalidate validate Markdown files against their schemas in editors that
  support LSP protocol (like VSCode and Neovim) identify errors by a red squiggly
  lines as they edit their Markdown.

## User Classes and Characteristics {#user-classes}

**Technical Hobbiests:**

These users are technical users who use Markdown on a daily basis to take
notes, and generally prefer text-based document formats. Many of these users
may be taking notes in markdown (e.g., Obsidian, Logseq, etc) and want to
ensure that their notes conform to a certain structure for better organization
and retrieval. Some will be developers looking to build meta-tooling incorporating
Markdown validation into their own applications.

**Corporate software engineers/Companies**:

These users, frequently write technical documentation, API specifications, and
design documents in Markdown format. They need standardized schemas to ensure
their documentation is consistently structured, machine-readable, and easily
consumable by AI systems for automated processing, code generation, and
knowledge extraction.

**AI Consumers**

AI systems increasingly require structured data formats for agentic behavior -
autonomous decision-making and task execution workflows that are currently
implemented using JSON schemas. However, Markdown offers significant advantages
in token efficiency, making it a more cost-effective alternative for AI
operations that process large volumes of structured content. By providing
schema validation for Markdown documents, this tool enables AI systems to both
enforce reproducible data structures for language model interactions and
generate consistent documentation from schema-driven data, potentially reducing
token costs and improving processing efficiency in high-frequency AI
applications.

## User Needs {#user-needs} 

We will initially focus on the x86_64/linux platform, but should be able to
build for macOS and Windows. (the actual validator will be a Rust binary that
should be able to build for all platforms).

## Design and Implementation Constraints {#design-constraints}

<!-- Wolf -->

<!-- Describe any items or issues that will limit the options available to the developers. These might
include: corporate or regulatory policies; hardware limitations (timing requirements, memory
requirements); interfaces to other applications; specific technologies, tools, and databases to be
used; parallel operations; language requirements; communications protocols; security
considerations; design conventions or programming standards (for example, if the customer's
organization will be responsible for maintaining the delivered software). -->

MDvalidate has some difficult and important core technical requirements:

**Incremental Validation**

It should be able to handle streamed input data that is not fully declared
initially. It should be able to "break" validating and say that the Markdown has
not validated before the rest of the Markdown has come in. This is useful in
applications where you are validating the output of an LLM in real-time, and
want to terminate the LLM's response before it finishes because it began to
output Markdown that does not conform to the schema.

**Malleability**

The tool we are building is intentionally very generic so that it can be used
for a large variety of different use cases. This means that we will need to
maintain interfaces that are suitable for human and machine interpretation. It
will be important that stick to CLI conventions like taking input files for the
validator via stdin and providing machine-readable output when the tty is a
non-user-interactive terminal via stdout and stderr.

**Performance**

One consideration that we will try to balance and keep in mind when designing
MDValidate is performance. We want to keep our schema declaration language
generic and logical, while also allowing it to be very flexible for the end
user. The more flexibility and look-ahead requirements in our language the
slower our interpreter/validator will be.

## User Documentation {#user-documentation}

<!-- Wolf -->

<!-- List the user documentation components (such as user manuals, on-line help, and tutorials) that
will be delivered along with the software. Identify any known user documentation delivery formats
or standards. -->

We will provide generated documentation using [clap](https://clap.rs/) for the
command line interface, and will also provide a simple Markdown `README.md` on
the GitHub repo that explains the basics for using MDvalidate.

For our actual custom schema description language, we will provide a document
that outlines the grammer and provide many examples.

## Assumptions and Dependencies {#assumptions-dependencies}

<!-- Wolf -->

<!-- List any assumed factors (as opposed to known facts) that could affect the requirements stated in
the SRS. These could include third-party or commercial components that you plan to use, issues
around the development or operating environment, or constraints. The project could be affected if
these assumptions are incorrect, are not shared, or change. Also identify any dependencies the
project has on external factors, such as software components that you intend to reuse from
another project, unless they are already documented elsewhere (for example, in the vision and
scope document or the project plan). -->

Markdown is a common language format but has some ambiguities. For the rest of
this document we will be assuming that Markdown refers to the
[CommonMark](https://commonmark.org/) specification of Markdown, which is a
well-defined and widely adopted standard. We will also strive to have support
for GitHub Flavored Markdown (GFM), additions, like Markdown tables.

# System Features

<!-- This template illustrates organizing the functional requirements for the product by system
features, the major services provided by the product. You may prefer to organize this section by
use case, mode of operation, user class, object class, functional hierarchy, or combinations of
these, whatever makes the most logical sense for your product. -->

## Technical Stack

The project will be written in Rust so that we can enforce strict memory
preconditions and achieve a high performance requirement.

We will use [Clap](https://github.com/clap-rs/clap) to build the command line
interface and do argument parsing, which is one of the most common rust CLI
libraries.

We will also use many common Rust development tools like
[Machete](https://github.com/bnjbvr/cargo-machete) and `cargo` tools.

To enable incremental parsing, which is important for streamed input and
real-time validation, we will use
[Treesitter](https://tree-sitter.github.io/tree-sitter/). Treesitter is an
incremental parsing library that allows us to generate an AST for given text
content, and then recompute the AST as the text changes. We may even be able to
define a grammer for our DSL with Treesitter grammers as well to make processing
our schema files easier.

This means that we can allow an input stream of Markdown text, which, for
example, could be generated from an LLM model, and incrementally validate the
AST of the document as it changes, allowing for real-time validation (and
termination).

When we get to implementing a language server for our validator, we will use
[Tower LSP](https://github.com/ebkalderon/tower-lsp), which is a Rust library to
build language servers. It is used by popular language LSPs like [Deno's
language server](https://docs.deno.com/runtime/reference/cli/lsp/).

To package our program, we will use [Nix](https://nixos.org/) for builds and
deployment/CI.

<!-- Itemize the detailed functional requirements associated with this feature. These are the
software capabilities that must be present in order for the user to carry out the
services provided by the feature, or to execute the use case. Include how the product
should respond to anticipated error conditions or invalid inputs. Requirements should
be concise, complete, unambiguous, verifiable, and necessary. Use "TBD" as a
placeholder to indicate when necessary information is not yet available.

Each requirement should be uniquely identified with a sequence number or a meaningful
tag of some kind. -->

## Feature 1: Schema Definition Language

### Description and Priority

**Priority: High**

DSL for defining Markdown document structure and constraints. This will include
a specification for writing code in our custom language.

### Stimulus/Response Sequences

- User creates `.mds` (markdown-schema) file -> Schema parsed and validated by MDvalidate
- Invalid schema syntax -> Error messages with line/column numbers in either a
  human or machine-readable format

### Functional Requirements

- Support specifying required/optional Markdown elements (headers, lists, code
  blocks) and patterns that they must conform to
- Define heading hierarchy constraints (e.g., H2 must follow H1)
- Returns clear error messages for malformed schemas (e.g., missing end tags,
  invalid regex, and associated labels)
- Support comments and whitespace for readability

## Feature 2: Command Line Validator Tool

### Description and Priority  

**Priority: Medium**

CLI tool that validates Markdown files against schemas.

### Stimulus/Response Sequences

- `mdvalidate schema.mds document.md` → Validation report
- `cat document.md | mdvalidate schema.mds` → Stream validation
- Invalid document → Detailed error report with line numbers
- Missing files → Clear error messages

### Functional Requirements

- Accept schema and Markdown file paths as arguments
- Accept Markdown content from stdin streams
- Parse Markdown into AST for validation
- Generate pass/fail reports with error locations
- Return appropriate exit codes
- Complete validation within 20ms for 1.3k characters (which is about twice as
  long as it takes for [the official `jsoncschema`
  validator](https://github.com/sourcemeta/jsonschema) to validate a JSON schema
  of about 1k characters)

## Feature 3: Language Server (LSP) Integration

### Description and Priority

**Priority: High**

LSP server for real-time Markdown validation.

### Stimulus/Response Sequences

- Schema violation detected -> Returns error messages
- Schema file changes -> All open Markdown files re-validated

### Functional Requirements

- Provide real-time diagnostics with error locations and messages, including
  incremental analysis (which will be important for streaming and LSP
  integration).
- Auto-detect schema files in project directories by using a $schema pragma in
  the Markdown's frontmatter


## Software Interfaces {#software-interfaces}

<!-- Wolf -->

<!-- Describe the connections between this product and other specific software
components (name and version), including databases, operating systems, tools,
libraries, and integrated commercial components. Identify the data items or
messages coming into the system and going out and describe the purpose of each.
Describe the services needed and the nature of communications. Refer to
documents that describe detailed application programming interface protocols.
Identify data that will be shared across software components. If the data
sharing mechanism must be implemented in a specific way (for example, use of a
global data area in a multitasking operating system), specify this as an
implementation constraint. -->

`mdvalidate` will function as a standalone Rust binary that can be run from the
command line. It will also offer a library interface for integration into other
tools, and will expose itself as a simple Rust crate (library).

```{mermaid}
graph LR
     A[".mds file"] --> B["./mdvalidate"]
      C["Markdown file"] --> B
      B --> D["Validation Report"]
```

You will use it by running commands that roughly look like

```bash
$$ echo "# (header:/First Name\:\w+/)" > schema.mds
$$ echo "# First Name: Wolf" > input.md"
$$ ./mdvalidate schema.mds input.md
Valid!
$$ echo $?
0
```

Or by providing in Markdown frontmatter a reference to the schema,

```bash
$$ cat <<EOF > schema.mds
---
schema: ./schema.mds
---
# (header:/First Name\:\w+/)
EOF
$$ echo "# First Name: Wolf" > input.md"
$$ ./mdvalidate schema.mds input.md
Valid!
$$ echo $?
0
```

# Other Nonfunctional Requirements

## Performance Requirements

<!-- If there are performance requirements for the product under various
circumstances, state them here and explain their rationale, to help the
developers understand the intent and make suitable design choices. Specify the
timing relationships for real time systems. Make such requirements as specific
as possible. You may need to state performance requirements for individual
functional requirements or features. -->

**Speed** 
Complete validation within 20ms for 1.3k characters (which is about twice as
long as it takes for [the official `jsoncschema`
validator](https://github.com/sourcemeta/jsonschema) to validate a JSON schema
of about 1k characters)

**Reliability**
The tool should be reliable and able to handle large volumes of content. We aim
to guarantee that if you validate a Markdown file it definitely conforms to your
schema.

**Scalability**
The tool should be scalable and able to handle large volumes of content. So we
aim to be able to handle 100k+ characters as an incoming stream without losing
significant efficiency in the process.

**Usability**
So we aim to be able to use `mdvalidate` with defaults with just 2 to 3
commands, and to conform to common CLI standards.

## Safety Requirements

<!-- Specify those requirements that are concerned with possible loss, damage,
or harm that could result from the use of the product. Define any safeguards or
actions that must be taken, as well as actions that must be prevented. Refer to
any external policies or regulations that state safety issues that affect the
product's design or use. Define any safety certifications that must be
satisfied. -->

- Handle corrupted or extremely large files gracefully without crashing or memory exhaustion
- Ensure robust error handling that fails safely when encountering unexpected
  input formats and provides a detailed report to the user
- Isolate validation processes and not use errors (`Result`s in Rust) for the
  validator components to prevent cascading failures affecting other system
  components
- General best practices for Rust to avoid panics wherever possible

## Security Requirements {#security-requirements}

<!-- Alessandro -->

<!-- Specify any requirements regarding security or privacy issues surrounding
use of the product or protection of the data used or created by the product.
Define any user identity authentication requirements. Refer to any external
policies or regulations containing security issues that affect the product.
Define any security or privacy certifications that must be satisfied. -->

Our program is designed to provide security guaranteess. It's highly critical
that we meet the requirements that we claim to have. Users will be trusting our
tool with arbitrarily shaped Markdown, potentially as a pre-processing step
before putting originally unstructured and potentially unsafe Markdown into
their database. This will mean that having good test coverage and many examples
for our validator will be very important.

## Software Quality Attributes

<!-- Specify any additional quality characteristics for the product that will be important to either the
customers or the developers. Some to consider are: adaptability, availability, correctness, flexibility,
interoperability, maintainability, portability, reliability, reusability, robustness, testability, and
usability. Write these to be specific, quantitative, and verifiable when possible. At the least, clarify
the relative preferences for various attributes, such as ease of use over ease of learning. -->

Our program will be accessible and downloadable by anyone with an internet
connection and a simple command line interface.

We will distribute MDvalidate via the [the Nix package
repository](https://search.nixos.org/packages), directly from GitHub.

# Other Requirements

The project is very standalone and doesn't need a server/web component. It can
be neatly packaged into a single binary!

<!-- Define any other requirements not covered elsewhere in the SRS. This might include database
requirements, internationalization requirements, legal requirements, reuse objectives for the
project, and so on. Add any new sections that are pertinent to the project. -->

# Appendix A: Glossary

<!-- Define all the terms necessary to properly interpret the SRS, including acronyms and
abbreviations. You may wish to build a separate glossary that spans multiple projects or the entire
organization, and just include terms specific to a single project in each SRS. -->

- **LSP**: Language server protocol, a protocol for language servers to communicate with
  editors and IDEs.
- **AST**: Abstract syntax tree, a tree representation of the abstract syntactic structure of 
  source code.
- **DSL**: Domain specific language, a programming language or specification language dedicated to
  a particular problem domain, a particular problem representation technique, and/or a particular
  solution technique.
- **MDvalidate**: The name of the Markdown validation tool we are building.
- **Markdown**: A lightweight markup language with plain text formatting syntax.
- **Schema**: A formal definition of the structure and constraints of a document or data format
  that MDvalidate will use to validate Markdown documents.
- **CommonMark**: A strongly defined, highly compatible specification of Markdown.
- **GFM**: GitHub Flavored Markdown, a dialect of Markdown that adds some features to the
  original Markdown specification, like tables.
- **Regex**: Regular expression, a sequence of characters that define a search pattern, often
  used for string matching within texts.

<!-- # Appendix B: Analysis Models -->

<!-- Optionally, include any pertinent analysis models, such as data flow diagrams, class diagrams,
state-transition diagrams, or entity-relationship diagrams. -->

<!-- # Appendix C: Issues List {#issues-list} -->

<!-- Wolf -->

<!-- This is a dynamic list of the open requirements issues that remain to be resolved, including
TBDs, pending decisions, information that is needed, conflicts awaiting resolution, and the like. -->
